# Управление потоком выполнения

## Условные конструкции

В Clojure, как и в других языках программирования, есть несколько способов создания условной логики. Давайте рассмотрим каждый из них:

### if

Самая простая условная конструкция - это `if`. Она похожа на тернарный оператор в Java:

```clojure
;; Clojure
(if (> x 0)
    "положительное"
    "отрицательное")

// Java эквивалент
x > 0 ? "положительное" : "отрицательное"
```

### cond

`cond` - это более мощная версия условной конструкции, похожая на множественные `if-else` в Java. Она особенно удобна, когда у вас несколько условий:

```clojure
(cond
  (< x 0)  "отрицательное"
  (> x 0)  "положительное"
  :else    "ноль")

// Java эквивалент
if (x < 0) {
    return "отрицательное";
} else if (x > 0) {
    return "положительное";
} else {
    return "ноль";
}
```

### case

`case` похож на `switch` в Java, но работает немного иначе. Он сравнивает значение с константами:

```clojure
(case day-of-week
  1 "Понедельник"
  2 "Вторник"
  "Неизвестный день")

// Java эквивалент
switch(dayOfWeek) {
    case 1: return "Понедельник";
    case 2: return "Вторник";
    default: return "Неизвестный день";
}
```

## Циклы через рекурсию и loop/recur

В функциональном программировании циклы обычно заменяются рекурсией. Это может быть непривычно для Java-разработчиков, но давайте разберем на примере:

### Рекурсия

```clojure
(defn sum-to [n]
  (if (<= n 0)
    0
    (+ n (sum-to (dec n)))))

// Java эквивалент с циклом
int sumTo(int n) {
    int sum = 0;
    for (int i = 1; i <= n; i++) {
        sum += i;
    }
    return sum;
}
```

### loop/recur

`loop/recur` - это специальная конструкция для оптимизации хвостовой рекурсии, которая позволяет избежать переполнения стека:

```clojure
(loop [n 10
       acc 0]
  (if (zero? n)
    acc
    (recur (dec n) (+ acc n))))
```

Это более эффективный способ написания циклов в Clojure, так как он не создает новые фреймы стека для каждой итерации.

## Обработка исключений

Обработка исключений в Clojure похожа на Java, но имеет свои особенности:

```clojure
(try
  (/ 1 0)
  (catch ArithmeticException e
    (println "Деление на ноль!"))
  (catch Exception e
    (println "Другая ошибка:" (.getMessage e)))
  (finally
    (println "Выполняется всегда")))

// Java эквивалент
try {
    1 / 0;
} catch (ArithmeticException e) {
    System.out.println("Деление на ноль!");
} catch (Exception e) {
    System.out.println("Другая ошибка: " + e.getMessage());
} finally {
    System.out.println("Выполняется всегда");
}
```

Основное отличие в том, что в Clojure исключения обычно используются реже, чем в Java. Вместо этого предпочтительно использовать другие механизмы обработки ошибок, такие как возврат специальных значений или использование монад (например, Either).

Важно отметить, что в функциональном программировании мы стараемся избегать исключений как способа управления потоком выполнения программы, предпочитая явное указание возможных ошибок в возвращаемых значениях функций.
