# Структуры данных в Clojure

## Коллекции: списки, векторы, множества, ассоциативные массивы

В Clojure, как и в других языках программирования, существуют различные типы коллекций для хранения и организации данных. Давайте рассмотрим основные типы:

### Списки (Lists)
Списки в Clojure - это связанные последовательности элементов, похожие на LinkedList в Java. Они оптимизированы для добавления элементов в начало и для последовательного доступа:

```clojure
;; Создание списка
(def my-list '(1 2 3 4))
;; или
(def another-list (list 1 2 3 4))
```

### Векторы (Vectors)
Векторы похожи на ArrayList в Java - это индексированные последовательности с быстрым произвольным доступом к элементам:

```clojure
;; Создание вектора
(def my-vector [1 2 3 4])
```

### Множества (Sets)
Множества - это коллекции уникальных элементов, аналогичные HashSet в Java:

```clojure
;; Создание множества
(def my-set #{1 2 3 4})
```

### Ассоциативные массивы (Maps)
Maps в Clojure аналогичны HashMap в Java, но с более богатым API:

```clojure
;; Создание map
(def my-map {:name "John" :age 30})
```

## Неизменяемость и персистентные структуры данных

Одно из ключевых отличий коллекций в Clojure от Java - это их неизменяемость (immutability). Если в Java вы можете изменить ArrayList, добавив или удалив элемент:

```java
ArrayList<Integer> list = new ArrayList<>();
list.add(1); // Изменяет существующий список
```

То в Clojure любая операция, которая "изменяет" коллекцию, на самом деле создает новую:

```clojure
(def numbers [1 2 3])
(def new-numbers (conj numbers 4)) 
;; numbers остается [1 2 3]
;; new-numbers становится [1 2 3 4]
```

Это достигается благодаря использованию персистентных структур данных, которые эффективно переиспользуют части существующих коллекций при создании новых версий. Это обеспечивает:
- Потокобезопасность без необходимости синхронизации
- Предсказуемость поведения программы
- Возможность легко отслеживать изменения данных

## Сравнение с Java-коллекциями

Давайте сравним основные операции:

### Java:
```java
// Изменяемые коллекции
ArrayList<String> list = new ArrayList<>();
list.add("A");        // Изменяет оригинал
list.remove(0);       // Изменяет оригинал

HashMap<String, Integer> map = new HashMap<>();
map.put("key", 1);    // Изменяет оригинал
map.remove("key");    // Изменяет оригинал
```

### Clojure:
```clojure
;; Неизменяемые коллекции
(def v [])
(def v2 (conj v "A"))     ;; Создает новый вектор
(def v3 (pop v2))         ;; Создает новый вектор

(def m {})
(def m2 (assoc m :key 1)) ;; Создает новую map
(def m3 (dissoc m2 :key)) ;; Создает новую map
```

Основные преимущества подхода Clojure:
1. Безопасность в многопоточной среде
2. Отсутствие побочных эффектов при работе с данными
3. Простота отладки (данные не могут быть неожиданно изменены)
4. Возможность эффективного кэширования

Основные отличия от Java-коллекций:
1. Все операции создают новые коллекции вместо изменения существующих
2. Более функциональный подход к обработке данных
3. Встроенная поддержка персистентности
4. Отсутствие необходимости в синхронизации при параллельной работе