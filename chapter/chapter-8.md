# Макросы и метапрограммирование

## Код как данные: синтаксические цитаты и макросы

В функциональных языках программирования, особенно в диалектах Lisp, существует уникальная концепция - возможность работать с кодом как с данными. Если в Java мы можем манипулировать строками, числами и объектами, то в функциональных языках мы можем так же легко манипулировать самим кодом программы.

Синтаксическая цитата - это способ представить код программы в виде структуры данных. Представьте, что вы можете взять любой фрагмент кода и "заморозить" его, превратив в объект, с которым можно работать. Это похоже на то, как если бы в Java вы могли взять целый метод и работать с ним как с объектом, изменяя его содержимое перед выполнением.

## Примеры простых макросов

Макросы - это мощный инструмент метапрограммирования, который позволяет писать код, генерирующий другой код. Если вы знакомы с аннотациями в Java или Kotlin, то можете провести некоторые параллели:

```java
// В Java мы используем аннотации для метапрограммирования
@Entity
public class User {
    @Id
    private Long id;
    @Column(name = "user_name")
    private String name;
}
```

Однако макросы гораздо мощнее аннотаций. Они выполняются на этапе компиляции и могут генерировать любой код. Вот простой пример макроса в Clojure:

```clojure
(defmacro unless [condition & body]
  `(if (not ~condition)
     (do ~@body)))

;; Использование:
(unless (empty? items)
  (println "Список не пуст")
  (process-items items))
```

Этот макрос создает новую управляющую конструкцию `unless`, которая является противоположностью `if`. В Java или Kotlin создание новых управляющих конструкций невозможно.

## Гигиена макросов

Гигиена макросов - это важный концепт, который решает проблему конфликтов имен при использовании макросов. Представьте ситуацию в Java:

```java
public void someMethod() {
    String result = "Hello";
    processResult(result -> {  // Лямбда использует имя 'result'
        // Что если внутри лямбды нам нужен доступ к внешней переменной result?
        // Возникает конфликт имен
    });
}
```

В макросах такие конфликты могут возникать чаще, так как макрос может генерировать код, использующий переменные. Гигиеничные макросы автоматически переименовывают переменные, чтобы избежать конфликтов.

Например, в Clojure:
```clojure
(defmacro with-resource [binding & body]
  `(let [resource# ~(second binding)]
     (try
       ~@body
       (finally
         (.close resource#)))))
```

Символ `#` в `resource#` указывает компилятору создать уникальное имя для этой переменной, исключая возможность конфликта с другими именами в области видимости.

Это особенно важно при создании библиотек макросов, так как они должны безопасно работать в любом контексте, не создавая конфликтов с пользовательским кодом.
