# Работа с функциями

## Определение функций

В Clojure, как и в других функциональных языках, функции являются основным строительным блоком программы. Давайте рассмотрим, как они определяются и используются.

### Определение функций через defn

Функции в Clojure определяются с помощью специальной формы `defn`. Это аналогично объявлению метода в Java, но с более простым синтаксисом:

```clojure
(defn приветствие [имя]
  (str "Привет, " имя "!"))
```

Это похоже на Java-метод:
```java
String greeting(String name) {
    return "Привет, " + name + "!";
}
```

### Лямбда-функции

Лямбды в Clojure создаются с помощью формы `fn` или сокращённой записи `#()`. Это аналогично лямбда-выражениям в Java:

```clojure
;; Полная форма
(fn [x] (* x 2))

;; Сокращённая форма
#(* % 2)
```

В Java это выглядело бы так:
```java
x -> x * 2
```

## Композиция функций

Композиция функций - это мощная концепция функционального программирования, которая позволяет создавать новые функции путём объединения существующих.

### comp

Функция `comp` позволяет объединить несколько функций в одну, где результат одной функции передаётся как аргумент следующей:

```clojure
(def удвоить-и-инкрементировать (comp inc *2))
;; Эквивалентно: (fn [x] (inc (*2 x)))
```

В Java это можно представить как:
```java
Function<Integer, Integer> doubleAndIncrement = x -> increment(doubleIt(x));
```

### partial

`partial` создаёт новую функцию с частично применёнными аргументами:

```clojure
(def прибавить-пять (partial + 5))
;; Эквивалентно: (fn [x] (+ 5 x))
```

В Java это можно сымитировать так:
```java
Function<Integer, Integer> addFive = x -> add(5, x);
```

## Замыкания

Замыкание - это функция, которая захватывает переменные из внешней области видимости. В Clojure любая функция, использующая переменные из внешнего контекста, является замыканием:

```clojure
(defn создать-счётчик []
  (let [счёт (atom 0)]
    (fn []
      (swap! счёт inc))))

(def счётчик (создать-счётчик))
```

В Java 8+ это аналогично:
```java
public Supplier<Integer> createCounter() {
    AtomicInteger count = new AtomicInteger(0);
    return () -> count.incrementAndGet();
}
```

Замыкания особенно полезны когда нужно сохранить состояние между вызовами функции, не прибегая к внешним переменным или классам.

## Заключение

Функции в Clojure являются "первоклассными гражданами", что означает, что их можно передавать как аргументы, возвращать из других функций и сохранять в переменных. Это делает код более гибким и выразительным по сравнению с традиционным объектно-ориентированным подходом.
