# Тестирование в Clojure

## Введение
Тестирование в Clojure, как и в других языках программирования, является важной частью разработки. Если вы знакомы с JUnit из Java или kotlintest из Kotlin, то многие концепции покажутся вам знакомыми, хотя есть и свои особенности.

## Фреймворки (clojure.test)
`clojure.test` - это встроенный фреймворк для модульного тестирования в Clojure. Он похож на JUnit, но имеет более простой и функциональный подход.

Пример простого теста:
```clojure
(ns my-app.core-test
  (:require [clojure.test :refer :all]
            [my-app.core :refer :all]))

(deftest addition-test
  (is (= 4 (+ 2 2)))
  (is (= 7 (+ 3 4))))
```

В отличие от Java/Kotlin, где мы используем аннотации `@Test`, в Clojure мы используем макрос `deftest`. Вместо методов `assertEquals` используется функция `is`, которая проверяет условия.

## Mocking и тестирование с побочными эффектами
В функциональном программировании особое внимание уделяется чистым функциям, но иногда нам нужно тестировать код, который взаимодействует с внешним миром (базы данных, HTTP-запросы, файловая система).

Для этого в Clojure есть несколько подходов:
1. `with-redefs` - встроенный механизм для переопределения функций во время тестирования
2. Библиотеки как `clj-http-fake` для мокирования HTTP-запросов

Пример использования `with-redefs`:
```clojure
(defn get-user-data []
  (http-client/get "http://api.example.com/user"))

(deftest test-user-data
  (with-redefs [http-client/get (fn [_] {:status 200 :body {:name "John"}})]
    (is (= {:name "John"} (get-user-data)))))
```

## Property-based testing (test.check)
Property-based testing - это мощный подход к тестированию, который может быть непривычен для разработчиков, пришедших из Java/Kotlin. Вместо написания конкретных тестовых случаев, мы определяем свойства, которым должна удовлетворять наша функция, а фреймворк генерирует тестовые данные.

test.check (порт QuickCheck из Haskell) автоматически генерирует множество тестовых случаев:

```clojure
(require '[clojure.test.check :as tc]
         '[clojure.test.check.generators :as gen]
         '[clojure.test.check.properties :as prop])

(def sort-idempotent-prop
  (prop/for-all [v (gen/vector gen/int)]
    (= (sort v) (sort (sort v)))))

(tc/quick-check 100 sort-idempotent-prop)
```

В этом примере мы проверяем свойство: "повторная сортировка отсортированного массива не меняет результат". test.check генерирует 100 случайных векторов целых чисел и проверяет это свойство.

## Заключение
Тестирование в Clojure может показаться необычным после Java/Kotlin, но оно предоставляет мощные инструменты:
- Простой и элегантный синтаксис для unit-тестов
- Функциональный подход к мокированию
- Продвинутые техники вроде property-based testing

Эти инструменты помогают писать надёжные тесты, которые проверяют как конкретные случаи, так и общие свойства вашего кода.