# Интеграция с Java

## Вызов Java-кода из Clojure (интероп)

Clojure работает поверх JVM и предоставляет прямой доступ к Java-классам и методам. Если вы знакомы с Java, то сможете легко использовать привычные вам библиотеки в Clojure-коде.

Вот несколько примеров:

```clojure
;; Создание Java-объектов
(def date (new java.util.Date))
;; или короче
(def date (java.util.Date.))

;; Вызов методов
(.toString date)
(.format (java.text.SimpleDateFormat. "dd/MM/yyyy") date)

;; Статические методы
(Math/abs -42)
```

Синтаксис немного отличается от Java, но концепции те же самые. Точка перед именем метода указывает на вызов метода объекта, а слэш используется для статических методов.

## Использование Clojure в Java-проектах

Clojure можно легко интегрировать в существующие Java-проекты. Это особенно полезно, когда вы хотите добавить функциональные возможности в ваше приложение или использовать преимущества Clojure для определенных задач.

Пример использования Clojure в Java-коде:

```java
import clojure.java.api.Clojure;
import clojure.lang.IFn;

public class ClojureIntegration {
    public static void main(String[] args) {
        // Загружаем и вызываем Clojure-функцию
        IFn plus = Clojure.var("clojure.core", "+");
        Object result = plus.invoke(1, 2, 3);
        System.out.println(result); // Выведет 6
    }
}
```

## Работа с Java-коллекциями и библиотеками

Если вы привыкли к Java-коллекциям, вы можете продолжать их использовать в Clojure. Однако Clojure предлагает свои иммутабельные коллекции, которые лучше подходят для функционального стиля программирования.

Сравнение работы с коллекциями:

```clojure
;; Java ArrayList в Clojure
(def java-list (new java.util.ArrayList))
(.add java-list "item")

;; Clojure vector
(def clj-vector ["item"])
(conj clj-vector "new-item")

;; Java HashMap в Clojure
(def java-map (new java.util.HashMap))
(.put java-map "key" "value")

;; Clojure map
(def clj-map {"key" "value"})
(assoc clj-map "new-key" "new-value")
```

### Важные отличия от Java:

1. В Clojure все коллекции иммутабельны по умолчанию. Операции над ними создают новые коллекции вместо изменения существующих.

2. Функции в Clojure являются объектами первого класса, их можно передавать как параметры (как лямбды в Java 8+).

3. Clojure использует динамическую типизацию, что может быть непривычно для Java-разработчиков.

### Для Kotlin-разработчиков:

Если вы знакомы с Kotlin, вам будет проще понять некоторые концепции Clojure:
- Null-safety в Clojure реализована через специальные формы, похожие на Kotlin's `?.`
- Иммутабельность по умолчанию, как в Kotlin с `val`
- Функциональные операции над коллекциями похожи на Kotlin's `map`, `filter`, `reduce`

### Рекомендации по интеграции:

1. Начните с малого: используйте Clojure для небольших утилитарных функций
2. Используйте преимущества обоих языков: Java для ООП и производительности, Clojure для функциональной обработки данных
3. Обратите внимание на управление зависимостями: Clojure использует Leiningen или deps.edn, которые нужно правильно интегрировать с Maven/Gradle

Помните, что Clojure предоставляет мощные возможности для метапрограммирования и работы с данными, которые могут значительно упростить некоторые задачи по сравнению с Java или Kotlin.
