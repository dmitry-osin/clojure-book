# Основы синтаксиса Clojure

## От императивного к функциональному: смена парадигмы

Если вы привыкли к Java или Kotlin, то ваше мышление во многом построено на императивном подходе: вы пишете последовательность инструкций, которые изменяют состояние программы шаг за шагом. Например, чтобы обработать список чисел, вы могли бы написать:

```java
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);
int sum = 0;
for (int num : numbers) {
    sum += num;
}
```

В функциональном программировании мы мыслим иначе. Вместо изменения состояния, мы описываем преобразования данных. Тот же пример на Clojure выглядел бы так:

```clojure
(reduce + [1 2 3 4 5])
```

Основные принципы функционального подхода:
- Иммутабельность: данные не изменяются после создания
- Чистые функции: результат зависит только от входных параметров
- Отсутствие побочных эффектов
- Функции как значения первого класса

## S-выражения и префиксная нотация

В Java/Kotlin вы привыкли к инфиксной нотации:
```java
int result = 2 + 3 * 4;
```

В Clojure используется префиксная нотация и S-выражения (символьные выражения):
```clojure
(+ 2 (* 3 4))
```

S-выражения всегда имеют форму `(оператор аргумент1 аргумент2 ...)`. Это может показаться непривычным, но даёт несколько преимуществ:
- Единообразие синтаксиса
- Отсутствие неоднозначности в порядке операций
- Простота парсинга и метапрограммирования

Сравните типичные операции:

Java:
```java
String name = "World";
System.out.println("Hello, " + name + "!");
```

Clojure:
```clojure
(def name "World")
(println (str "Hello, " name "!"))
```

## Базовые элементы

### Функции

В Clojure функции определяются с помощью `defn`:

```clojure
(defn greet [name]
  (str "Hello, " name "!"))
```

Функции можно передавать как параметры:
```clojure
(map inc [1 2 3]) ; => (2 3 4)
```

### Переменные (def)

В отличие от переменных в Java/Kotlin, `def` создает неизменяемые привязки:

```clojure
(def pi 3.14159)
(def greeting "Hello")
```

Это больше похоже на константы в Java (`final`) или `val` в Kotlin.

### Примитивные типы

Clojure использует те же примитивные типы, что и Java:
- Числа: `42` (Long), `3.14` (Double)
- Строки: `"Hello"`
- Булевы значения: `true`, `false`
- `nil` (аналог `null`)

Но также добавляет собственные коллекции:
- Векторы: `[1 2 3]`
- Списки: `'(1 2 3)`
- Множества: `#{1 2 3}`
- Словари: `{:a 1 :b 2}`

Важно понимать, что все эти структуры данных иммутабельны. Когда вы "изменяете" их, на самом деле создаётся новая версия с нужными изменениями.